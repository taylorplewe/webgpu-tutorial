<!DOCTYPE html>
<html>
	<head>
		<title>Web GPU Tutorial</title>
		<script type="module">
	



const canvasEl = document.querySelector('canvas');
if (!navigator.gpu) {
	throw new Error('WebGPU not supported in this browser!!');
}
const adapter = await navigator.gpu.requestAdapter();
if (!adapter) {
	throw new Error("No appropriate GPUAdapter found.");
}
const device = await adapter.requestDevice();
if (!device) {
	throw new Error("No appropriate GPUDevice found.");
}

const context = canvasEl.getContext('webgpu');
const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
context.configure({
	device: device,
	format: canvasFormat,
});

const GRID_SIZE = 32;
const vertices = new Float32Array([
//   X,    Y,
  -0.8, -0.8, // Triangle 1
   0.8, -0.8,
   0.8,  0.8,

  -0.8, -0.8, // Triangle 2
   0.8,  0.8,
  -0.8,  0.8,
]);

const vertexBuffer = device.createBuffer({
	label: 'Cell vertices',
	size: vertices.byteLength,
	usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
});
device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/0, vertices);
const uniformArray = new Float32Array([GRID_SIZE, GRID_SIZE]);
const uniformBuffer = device.createBuffer({
	label: 'Grid uniforms',
	size: uniformArray.byteLength,
	usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
});
device.queue.writeBuffer(uniformBuffer, 0, uniformArray);

const vertexBufferLayout = {
	arrayStride: 8,
	attributes: [{
		format: 'float32x2',
		offset: 0,
		shaderLocation: 0, // position, see vertex shader
	}],
};
const cellShaderModule = device.createShaderModule({
	label: 'Cell shader',
	code: `
		@group(0) @binding(0) var<uniform> gridSize: vec2f;

		@vertex
		fn vertexMain(@location(0) pos: vec2f, @builtin(instance_index) instance: u32) -> @builtin(position) vec4f {
			let i = f32(instance);
			let cellPos = vec2f(i % gridSize.x, floor(i / gridSize.x));
			let cellOffset = (cellPos / gridSize) * 2;
			let gridPos = (((pos + 1) / gridSize) - 1) + cellOffset;

			return vec4f(gridPos, 0, 1); // (x, y, z, w)
		}

		@fragment
		fn fragmentMain() -> @location(0) vec4<f32> {
			return vec4<f32>(1.0, 0.0, 0.0, 1.0);
		}
	`
});
const cellPipeline = device.createRenderPipeline({
	label: 'Cell pipeline',
	layout: 'auto',
	vertex: {
		module: cellShaderModule,
		entryPoint: 'vertexMain',
		buffers: [vertexBufferLayout],
	},
	fragment: {
		module: cellShaderModule,
		entryPoint: 'fragmentMain',
		targets: [{
			format: canvasFormat,
		}],
	},
});

const bindGroup = device.createBindGroup({
	label: 'Cell renderer bind group',
	layout: cellPipeline.getBindGroupLayout(0),
	entries: [{
		binding: 0,
		resource: {
			buffer: uniformBuffer,
		},
	}],
});

const encoder = device.createCommandEncoder();
const pass = encoder.beginRenderPass({
	colorAttachments: [{
		view: context.getCurrentTexture().createView(),
		loadOp: 'clear',
		clearValue: { r: 0.2, g: 0.2, b: 0.2, a: 1 },
		storeOp: 'store',
	}]
});

pass.setPipeline(cellPipeline);
pass.setVertexBuffer(0, vertexBuffer);
pass.setBindGroup(0, bindGroup);
pass.draw(vertices.length / 2, GRID_SIZE * GRID_SIZE);

pass.end();
device.queue.submit([encoder.finish()]);



		</script>
	</head>
	<body>
		<h1>test</h1>
		<canvas width="512" height="512"></canvas>
	</body>
</html>