<!DOCTYPE html>
<html>
	<head>
		<title>Web GPU Tutorial</title>
		<style>body { background-color: #111; color: #aaa; }</style>
		<script type="module">
	



const canvasEl = document.querySelector('canvas');
if (!navigator.gpu) {
	throw new Error('WebGPU not supported in this browser!!');
}
const adapter = await navigator.gpu.requestAdapter();
if (!adapter) {
	throw new Error("No appropriate GPUAdapter found.");
}
const device = await adapter.requestDevice();
if (!device) {
	throw new Error("No appropriate GPUDevice found.");
}

const context = canvasEl.getContext('webgpu');
const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
context.configure({
	device: device,
	format: canvasFormat,
});

const GRID_SIZE = 32;
const vertices = new Float32Array([
//   X,    Y,
  -0.8, -0.8, // Triangle 1
   0.8, -0.8,
   0.8,  0.8,

  -0.8, -0.8, // Triangle 2
   0.8,  0.8,
  -0.8,  0.8,
]);

const vertexBuffer = device.createBuffer({
	label: 'Cell vertices',
	size: vertices.byteLength,
	usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
});
device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/0, vertices);
const uniformArray = new Float32Array([GRID_SIZE, GRID_SIZE]);
const uniformBuffer = device.createBuffer({
	label: 'Grid uniforms',
	size: uniformArray.byteLength,
	usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
});
device.queue.writeBuffer(uniformBuffer, 0, uniformArray);

const cellStateArray = new Uint32Array(GRID_SIZE * GRID_SIZE);
const cellStateStorage = [
	device.createBuffer({
		label: "Cell State",
		size: cellStateArray.byteLength,
		usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
	}),
	device.createBuffer({
		label: "Cell State",
		size: cellStateArray.byteLength,
		usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
	}),
];
for (let i = 0; i < cellStateArray.length; i += 3) {
  cellStateArray[i] = 1;
}
device.queue.writeBuffer(cellStateStorage[0], 0, cellStateArray);
for (let i = 0; i < cellStateArray.length; i++) {
  cellStateArray[i] = i % 2;
}
device.queue.writeBuffer(cellStateStorage[1], 0, cellStateArray);

const vertexBufferLayout = {
	arrayStride: 8,
	attributes: [{
		format: 'float32x2',
		offset: 0,
		shaderLocation: 0, // position, see vertex shader
	}],
};
const cellShaderModule = device.createShaderModule({
	label: 'Cell shader',
	code: `
		struct VertexInput  {
			@location(0) pos: vec2f,
			@builtin(instance_index) instance: u32,
		}
		struct VertexOutput {
			@builtin(position) pos: vec4f,
			@location(0) cell: vec2f,
		}
		@group(0) @binding(0) var<uniform> gridSize: vec2f;
		@group(0) @binding(1) var<storage> cellState: array<u32>;

		@vertex
		fn vertexMain(in: VertexInput) -> VertexOutput {
			let i = f32(in.instance);
			let cellPos = vec2f(i % gridSize.x, floor(i / gridSize.x));
			let cellOffset = (cellPos / gridSize) * 2;
			let state = f32(cellState[in.instance]);
			let gridPos = (((in.pos*state + 1) / gridSize) - 1) + cellOffset;

			var out: VertexOutput;
			out.pos = vec4f(gridPos, 0, 1); // (x, y, z, w)
			out.cell = cellPos;
			return out;
		}

		@fragment
		fn fragmentMain(in: VertexOutput) -> @location(0) vec4<f32> {
			let c = in.cell/gridSize;
			return vec4<f32>(c, 1-c.x, 1.0);
		}
	`
});
const cellPipeline = device.createRenderPipeline({
	label: 'Cell pipeline',
	layout: 'auto',
	vertex: {
		module: cellShaderModule,
		entryPoint: 'vertexMain',
		buffers: [vertexBufferLayout],
	},
	fragment: {
		module: cellShaderModule,
		entryPoint: 'fragmentMain',
		targets: [{
			format: canvasFormat,
		}],
	},
});

const bindGroups = [
	device.createBindGroup({
		label: 'Cell renderer bind group',
		layout: cellPipeline.getBindGroupLayout(0),
		entries: [
			{
				binding: 0,
				resource: {
					buffer: uniformBuffer,
				},
			},
			{
				binding: 1,
				resource: {
					buffer: cellStateStorage[0],
				},
			},
		],
	}),
	device.createBindGroup({
		label: 'Cell renderer bind group',
		layout: cellPipeline.getBindGroupLayout(0),
		entries: [
			{
				binding: 0,
				resource: {
					buffer: uniformBuffer,
				},
			},
			{
				binding: 1,
				resource: {
					buffer: cellStateStorage[1],
				},
			},
		],
	}),
];

const UPDATE_INTERVAL = 200;
let step = 0;
const update = () => {
	const encoder = device.createCommandEncoder();
	const pass = encoder.beginRenderPass({
		colorAttachments: [{
			view: context.getCurrentTexture().createView(),
			loadOp: 'clear',
			clearValue: { r: 0.2, g: 0.2, b: 0.2, a: 1 },
			storeOp: 'store',
		}]
	});

	pass.setPipeline(cellPipeline);
	pass.setVertexBuffer(0, vertexBuffer);
	pass.setBindGroup(0, bindGroups[step % 2]);
	pass.draw(vertices.length / 2, GRID_SIZE * GRID_SIZE);

	pass.end();
	device.queue.submit([encoder.finish()]);

	step++;
}
setInterval(update, UPDATE_INTERVAL);



		</script>
	</head>
	<body>
		<h1>test</h1>
		<canvas width="512" height="512"></canvas>
	</body>
</html>